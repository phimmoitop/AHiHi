name: AHiHi to CF (AI Anime Master - Strictly Original Specs)

on:
  workflow_dispatch:
    inputs:
      type: { description: "Type", required: true }
      slug: { description: "Slug", required: true }
      ss: { description: "Season", required: true }
      ep: { description: "Ep", required: true }
      hid: { description: "Hid", required: true }
      token: { description: 'Token', required: true }
      page: { description: 'Page', required: true }
      account: { description: 'AID', required: true }
      key: { description: 'Gemini API Key', required: true }

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Environment
        run: |
          sudo apt update
          sudo apt install -y ffmpeg curl jq unzip fontconfig python3 python3-pip
          python3 -m pip install --upgrade pip
          python3 -m pip install webvtt-py requests edge-tts

      # ================= FONT =================
      - name: Setup Subtitle Font (Oswald)
        run: |
          mkdir -p fonts
          curl -L https://github.com/phimmoitop/AHiHi/raw/main/Oswald.zip -o oswald.zip
          unzip -o oswald.zip -d fonts
          fc-cache -f fonts
          fc-list | grep -i oswald || true

      # ================= GET LINKS =================
      - name: Get download & subtitle link
        run: |
          HID="${{ github.event.inputs.hid }}"
          EP="${{ github.event.inputs.ep }}"
          RESP1=$(curl -s "https://hihianimeapi.onrender.com/api/v1/episodes/a-${HID}")
          LINK_EP=$(echo "$RESP1" | jq -r ".data[] | select(.episodeNumber == ($EP|tonumber)) | .id")
          RESP2=$(curl -s "https://hihianimeapi.onrender.com/api/v1/stream?type=sub&server=hd-2&id=${LINK_EP}")
          echo "LINK_DL=$(echo "$RESP2" | jq -r '.data.link.file')" >> $GITHUB_ENV
          echo "LINK_SUB=$(echo "$RESP2" | jq -r '.data.tracks[]? | select(.label=="English") | .file' | head -n1)" >> $GITHUB_ENV

      # ================= DOWNLOAD =================
      - name: Download Video & Subtitle
        run: |
          ffmpeg -y -i "$LINK_DL" -c copy -bsf:a aac_adtstoasc raw_video.mp4
          curl -L "$LINK_SUB" -o eng.vtt

      # ================= TRANSLATE + TTS =================
      - name: AI Translate + TTS (STABLE)
        env:
          GEMINI_API_KEY: ${{ github.event.inputs.key }}
        run: |
          python3 <<'EOF'
          import webvtt, os, time, re, requests, asyncio, edge_tts, subprocess

          API_KEY = os.environ['GEMINI_API_KEY']

          def get_model():
              res = requests.get(
                  f"https://generativelanguage.googleapis.com/v1/models?key={API_KEY}"
              ).json()
              for t in ['gemini-2.5-flash','gemini-2.0-flash','gemini-1.5-flash']:
                  for m in res.get('models', []):
                      if t in m['name']:
                          return m['name']
              return res['models'][0]['name']

          def safe_text(text, max_len=450):
              text = re.sub(r'\s+', ' ', text).strip()
              return text if len(text) <= max_len else text[:max_len] + "..."

          def to_ssml(text):
              repl = {
                  ",": "<break time='200ms'/>",
                  ".": "<break time='400ms'/>",
                  "?": "<break time='500ms'/>",
                  "!": "<break time='500ms'/>",
                  "…": "<break time='600ms'/>"
              }
              for k, v in repl.items():
                  text = text.replace(k, v)
              return f"<speak>{text}</speak>"

          async def generate_tts(text, out, idx):
              try:
                  ssml = to_ssml(text)
                  tts = edge_tts.Communicate(
                      ssml,
                      voice="vi-VN-HoaiMyNeural",
                      rate="+25%"
                  )
                  await tts.save(out)

                  if not os.path.exists(out) or os.path.getsize(out) < 1000:
                      raise Exception("Empty audio")

                  print(f"[TTS OK] #{idx}")

              except Exception as e:
                  print(f"[TTS FAIL] #{idx}: {e}")
                  subprocess.run(
                      [
                          "ffmpeg","-y","-f","lavfi","-i",
                          "anullsrc=r=24000:cl=mono","-t","0.2",out
                      ],
                      stdout=subprocess.DEVNULL,
                      stderr=subprocess.DEVNULL
                  )

          async def main():
              model = get_model()
              print("Using model:", model)

              vtt = webvtt.read("eng.vtt")
              total = len(vtt)
              all_vi = [None] * total

              for i in range(0, total, 30):
                  batch = vtt[i:i+30]
                  prompt = "Dịch sang tiếng Việt (Anime style). Giữ ID: Nội dung.\n\n"
                  prompt += "\n".join(
                      f"{i+j}: {c.text.replace(chr(10),' ')}"
                      for j, c in enumerate(batch)
                  )

                  url = f"https://generativelanguage.googleapis.com/v1beta/{model}:generateContent?key={API_KEY}"
                  try:
                      r = requests.post(
                          url,
                          json={"contents":[{"parts":[{"text":prompt}]}]},
                          timeout=60
                      )
                      data = r.json()

                      if "error" in data:
                          print("[GEMINI ERROR]", data["error"])
                          continue

                      candidates = data.get("candidates")
                      if not candidates:
                          print("[GEMINI EMPTY]")
                          continue

                      txt = candidates[0]["content"]["parts"][0]["text"]

                      for line in txt.splitlines():
                          m = re.match(r'^(\d+):\s*(.+)', line.strip())
                          if m:
                              idx = int(m.group(1))
                              if 0 <= idx < total:
                                  all_vi[idx] = m.group(2)

                  except Exception as e:
                      print("[GEMINI FAIL]", e)

                  time.sleep(1)

              os.makedirs("chunks", exist_ok=True)
              vi_vtt = webvtt.WebVTT()
              tasks = []

              for i, c in enumerate(vtt):
                  raw = all_vi[i] if all_vi[i] else c.text.replace('\n', ' ')
                  txt = safe_text(raw)
                  vi_vtt.captions.append(
                      webvtt.Caption(c.start, c.end, txt)
                  )
                  tasks.append(
                      generate_tts(txt, f"chunks/c_{i}.mp3", i)
                  )

              await asyncio.gather(*tasks)
              vi_vtt.save("vi.vtt")
              print("DONE")

          asyncio.run(main())
          EOF


      # ================= FILTER =================
      - name: Build Filter
        run: |
          python3 <<EOF
          import webvtt
          vtt = webvtt.read("vi.vtt")
          with open("master_filter.txt","w") as f:
              for i,c in enumerate(vtt):
                  h,m,s = c.start.replace(',','.').split(':')
                  ms = int(float(h)*3600000 + float(m)*60000 + float(s)*1000)
                  f.write(f"[{i+1}:a]adelay={ms}|{ms}[a{i}];")
              f.write("".join(f"[a{i}]" for i in range(len(vtt))))
              f.write(f"amix=inputs={len(vtt)}:normalize=0,volume=2.0[tts];")
              f.write("[0:a]volume=0.75[bg];[bg][tts]amix=inputs=2[out_audio];")
              f.write("[0:v]subtitles=vi.vtt:fontsdir=fonts:force_style='FontName=Oswald,FontSize=22,Outline=1,Shadow=0.5'[out_video]")
          EOF

      # ================= RENDER =================
      - name: Render & HLS
        run: |
          NAME="${{ github.event.inputs.type }}-${{ github.event.inputs.slug }}-${{ github.event.inputs.ss }}-${{ github.event.inputs.ep }}"
          INPUTS="-i raw_video.mp4"
          for f in chunks/*.mp3; do INPUTS="$INPUTS -i $f"; done

          ffmpeg -y $INPUTS -filter_complex_script master_filter.txt \
            -map "[out_video]" -map "[out_audio]" \
            -c:v libx264 -crf 22 -preset fast \
            -force_key_frames "expr:gte(t,n_forced*5)" \
            -c:a aac -b:a 128k final.mp4

          mkdir -p output
          ffmpeg -i final.mp4 -c copy -f hls \
            -hls_time 5 -hls_list_size 0 -hls_playlist_type vod \
            -hls_segment_type fmp4 \
            -hls_fmp4_init_filename "${NAME}-index.png" \
            -hls_segment_filename "output/${NAME}-index%d.png" \
            "output/${NAME}.m3u8"

          cp vi.vtt output/

      # ================= DEPLOY =================
      - name: Deploy to Cloudflare Pages
        uses: cloudflare/pages-action@v1
        with:
          apiToken: ${{ github.event.inputs.token }}
          accountId: ${{ github.event.inputs.account }}
          projectName: ${{ github.event.inputs.page }}
          directory: ./output
          branch: ${{ github.event.inputs.type }}-${{ github.event.inputs.slug }}-${{ github.event.inputs.ss }}-${{ github.event.inputs.ep }}
