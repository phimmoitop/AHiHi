name: AHiHi to CF (AI Anime Master - Fixed & Auto Debug)

on:
  workflow_dispatch:
    inputs:
      type: { description: "Type", required: true }
      slug: { description: "Slug", required: true }
      ss: { description: "Season", required: true }
      ep: { description: "Ep", required: true }
      hid: { description: "Hid", required: true }
      token: { description: 'Token', required: true }
      page: { description: 'Page', required: true }
      account: { description: 'AID', required: true }
      key: { description: 'Gemini API Key', required: true }

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Environment
        run: |
          sudo apt update
          sudo apt install -y ffmpeg curl jq python3 python3-pip
          python3 -m pip install --upgrade pip
          python3 -m pip install webvtt-py requests

      - name: Get download and subtitle link
        id: getlink
        run: |
          HID="${{ github.event.inputs.hid }}"
          EP="${{ github.event.inputs.ep }}"
          RESP1=$(curl -s "https://hihianimeapi.onrender.com/api/v1/episodes/a-${HID}")
          LINK_EP=$(echo "$RESP1" | jq -r ".data[] | select(.episodeNumber == ($EP|tonumber)) | .id")
          RESP2=$(curl -s "https://hihianimeapi.onrender.com/api/v1/stream?type=sub&server=hd-2&id=${LINK_EP}")
          LINK_DL=$(echo "$RESP2" | jq -r '.data.link.file')
          LINK_SUB=$(echo "$RESP2" | jq -r '.data.tracks[]? | select(.label == "English") | .file' | head -n 1)
          if [ -z "$LINK_SUB" ] || [ "$LINK_SUB" == "null" ]; then
            LINK_SUB=$(echo "$RESP2" | jq -r '.data.tracks[0].file')
          fi
          echo "LINK_DL=$LINK_DL" >> $GITHUB_ENV
          echo "LINK_SUB=$LINK_SUB" >> $GITHUB_ENV

      - name: Download video and subtitle
        run: |
          ffmpeg -i "$LINK_DL" -c copy -bsf:a aac_adtstoasc "raw_video.mp4"
          curl -L "$LINK_SUB" -o "eng.vtt"

      - name: AI Translation with Auto Debug
        env:
          GEMINI_API_KEY: ${{ github.event.inputs.key }}
        run: |
          python3 <<'EOF'
          import webvtt
          import os, time, re, requests, json

          API_KEY = os.environ['GEMINI_API_KEY']

          def debug_and_get_model():
              print("ðŸ” --- DEBUG: ÄANG KIá»‚M TRA TÃ€I KHOáº¢N ---")
              url = f"https://generativelanguage.googleapis.com/v1/models?key={API_KEY}"
              try:
                  res = requests.get(url)
                  if res.status_code != 200:
                      print(f"âŒ KhÃ´ng thá»ƒ láº¥y danh sÃ¡ch Model. Lá»—i: {res.text}")
                      return None
                  
                  models = res.json().get('models', [])
                  available_names = [m['name'] for m in models if 'generateContent' in m['supportedGenerationMethods']]
                  
                  print("âœ… CÃ¡c AI kháº£ dá»¥ng trong tÃ i khoáº£n cá»§a báº¡n:")
                  for name in available_names:
                      print(f"  - {name}")
                  
                  # Æ¯u tiÃªn chá»n
                  for target in ['gemini-1.5-flash', 'gemini-1.5-pro', 'gemini-1.0-pro', 'gemini-pro']:
                      for name in available_names:
                          if target in name:
                              print(f"ðŸŽ¯ ÄÃ£ chá»n Model tá»‘i Æ°u nháº¥t: {name}")
                              return name
                  return available_names[0] if available_names else None
              except Exception as e:
                  print(f"âŒ Lá»—i Debug: {e}")
                  return None

          def translate_text(model_name, prompt_text):
              # Sá»­ dá»¥ng v1beta cho cÃ¡c model má»›i, v1 cho model cÅ©
              version = "v1beta" if "1.5" in model_name else "v1"
              url = f"https://generativelanguage.googleapis.com/{version}/{model_name}:generateContent?key={API_KEY}"
              
              headers = {"Content-Type": "application/json"}
              payload = {
                  "contents": [{"parts": [{"text": prompt_text}]}],
                  "generationConfig": {"temperature": 0.2}
              }

              try:
                  response = requests.post(url, headers=headers, data=json.dumps(payload), timeout=60)
                  res_json = response.json()
                  if response.status_code == 200:
                      return res_json["candidates"][0]["content"]["parts"][0]["text"]
                  else:
                      print(f"âš ï¸ Lá»—i API táº¡i {model_name}: {res_json.get('error', {}).get('message')}")
              except Exception as e:
                  print(f"âŒ Lá»—i káº¿t ná»‘i: {e}")
              return None

          def process():
              if not os.path.exists('eng.vtt'):
                  print("âŒ File eng.vtt khÃ´ng tá»“n táº¡i.")
                  return

              chosen_model = debug_and_get_model()
              if not chosen_model:
                  print("âŒ KhÃ´ng tÃ¬m tháº¥y Model nÃ o Ä‘á»ƒ dá»‹ch. Dá»«ng workflow.")
                  return

              vtt = webvtt.read('eng.vtt')
              total = len(vtt)
              batch_size = 25
              all_translated_texts = [None] * total

              print(f"ðŸš€ Báº¯t Ä‘áº§u dá»‹ch {total} cÃ¢u báº±ng {chosen_model}...")

              for i in range(0, total, batch_size):
                  batch = vtt[i:i+batch_size]
                  en_text = ""
                  for idx, cap in enumerate(batch):
                      # Loáº¡i bá» xuá»‘ng dÃ²ng trong ná»™i dung sub Ä‘á»ƒ trÃ¡nh lá»—i Ä‘á»‹nh dáº¡ng
                      clean_content = cap.text.replace('\n', ' ').strip()
                      en_text += f"{i+idx}: {clean_content}\n"

                  prompt = f"Dá»‹ch sang tiáº¿ng Viá»‡t phong cÃ¡ch Anime. Báº®T BUá»˜C giá»¯ Ä‘á»‹nh dáº¡ng 'ID: Ná»™i dung'. KhÃ´ng giáº£i thÃ­ch thÃªm.\n\n{en_text}"
                  
                  translated_part = translate_text(chosen_model, prompt)
                  if translated_part:
                      clean_res = translated_part.replace('```', '').replace('plaintext', '').strip()
                      for line in clean_res.splitlines():
                          m = re.match(r'^(\d+):\s*(.+)', line.strip())
                          if m:
                              idx = int(m.group(1))
                              text = m.group(2).strip()
                              if 0 <= idx < total:
                                  all_translated_texts[idx] = text
                  
                  print(f"âœ… HoÃ n thÃ nh batch {i}")
                  time.sleep(2) # TrÃ¡nh Rate Limit cho tÃ i khoáº£n Free

              # LÆ°u file VTT má»›i
              vi_vtt = webvtt.WebVTT()
              for i, cap in enumerate(vtt):
                  text_vi = all_translated_texts[i] if all_translated_texts[i] else cap.text
                  vi_vtt.captions.append(webvtt.Caption(cap.start, cap.end, text_vi))
              
              vi_vtt.save('vi.vtt')
              print("âœ¨ ÄÃ£ táº¡o thÃ nh cÃ´ng file vi.vtt")

          process()
          EOF

      - name: Final Render & Accurate HLS
        run: |
          NAME="${{ github.event.inputs.type }}-${{ github.event.inputs.slug }}-${{ github.event.inputs.ss }}-${{ github.event.inputs.ep }}"
          
          # Render Hardsub vá»›i style yÃªu cáº§u
          ffmpeg -y -i raw_video.mp4 \
            -vf "subtitles=vi.vtt:force_style='FontSize=20,PrimaryColour=&H00FFFF&,Outline=1,Shadow=1'" \
            -c:v libx264 -preset superfast -crf 22 \
            -c:a copy \
            "final_video.mp4"

          mkdir -p output
          # Chuyá»ƒn Ä‘á»•i sang HLS giáº£ láº­p PNG cho Cloudflare
          ffmpeg -i final_video.mp4 -c copy \
            -f hls \
            -hls_time 5 \
            -hls_list_size 0 \
            -hls_playlist_type vod \
            -hls_segment_type fmp4 \
            -hls_fmp4_init_filename "${NAME}-index.png" \
            -hls_segment_filename "output/${NAME}-index%d.png" \
            "output/${NAME}.m3u8"
          
          cp vi.vtt output/

      - name: Deploy to Cloudflare Pages
        uses: cloudflare/pages-action@v1
        with:
          apiToken: ${{ github.event.inputs.token }}
          accountId: ${{ github.event.inputs.account }}
          projectName: ${{ github.event.inputs.page }}
          directory: ./output
          branch: ${{ github.event.inputs.type }}-${{ github.event.inputs.slug }}-${{ github.event.inputs.ss }}-${{ github.event.inputs.ep }}
